// This test looks for a function-like macro with the right name to exist. For
// now the test doesn't require any specific code to be generated by the macro,
// so returning an empty TokenStream should be sufficient.
// 此测试寻找具有正确名称的类似函数的宏。
// 目前，测试不需要宏生成任何特定代码，因此返回一个空的TokenStream应该就足够了。
//
// Before moving on to the next test, you'll want some code in your
// implementation to handle parsing the first few tokens of input. The macro
// should expect the input to contain a syn::Ident, Token![in], syn::LitInt,
// Token![..], syn::LitInt.

// 在进行下一个测试之前，您需要在实现中提供一些代码来处理前几个输入令牌的解析。
// 宏应该期望输入包含syn::Ident, Token![in], syn::LitInt,
// Token![..], syn::LitInt.
//
// It is also possible to implement this project without using Syn if you'd
// like, though you will end up writing more code, more tedious code, and more
// explicit error handling than when using Syn as a parsing library.
//
// 如果您愿意，也可以在不使用Syn的情况下实现此项目，尽管与使用Syn作为解析库相比，您最终会编写更多的代码、更繁琐的代码和更明确的错误处理。
//
// Resources:
//
//   - Parsing in Syn:
//     https://docs.rs/syn/2.0/syn/parse/index.html
//
//   - An example of a function-like procedural macro implemented using Syn:
//     https://github.com/dtolnay/syn/tree/master/examples/lazy-static

use seq::seq;

seq!(N in 0..8 {
    // nothing
});

fn main() {}
